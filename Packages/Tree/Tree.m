(* ::Package:: *)

(* Autogenerated Package *)

Tree::usage="A Tree data structure";


TreeNode::usage="A TreeNode object which exists as a symbolic wrapper on node data";


TreeData::usage="Extracts data from a node";
TreeChildren::usage="Pulls children out of a node";
TreeChildCount::usage="Counts the number of leaves in the tree";


TreeInsert::usage="Inserts a node into a tree";
TreePop::usage="Pops a node (and children) from a tree";
TreeReplace::usage="Replaces a node in a tree";


TreeInsertData::usage="Inserts into the data field of each node";
TreePopData::usage="Deletes from the data field of each node";
TreeReplaceData::usage="Replaces data in a tree";


TreeInsertSequence::usage="Inserts a sequence of nodes into a Tree";
TreeReplaceSequence::usage="Replaces a sequence of nodes in a Tree";
TreePopSequence::usage="Pops a sequence of nodes in a Tree";


TreeWalk::usage="Walks a tree";


Begin["`Private`"];


(* ::Text:: *)
(*
	We\[CloseCurlyQuote]ll use a linked-list implementation to get efficient sub-tree-ing
	This will feel rather like our Stack implementation, honestly... but rather than introducing pushes and pops we\[CloseCurlyQuote]ll introduce tree insertion, deletion, rearrangement, and walking
*)



(* ::Subsection:: *)
(*Tree*)



(* ::Subsubsection::Closed:: *)
(*Constructor*)



(* ::Subsubsubsection::Closed:: *)
(*Tree*)



Tree//ClearAll;
Tree[]:=Tree[{{}, {}}];
unconstructedQ=
  Function[Null, System`Private`EntryQ[Unevaluated[#]], HoldFirst];
q:Tree[l_List]?unconstructedQ:=
System`Private`SetNoEntry[Unevaluated@q]


newTree[list_]:=
  System`Private`SetNoEntry@
    Unevaluated[Tree[list]]


(* ::Subsubsubsection::Closed:: *)
(*TreeNode*)



TreeNode//Clear
TreeNode[]:=TreeNode[{}(* data field *), {}(*children field *)];
n:TreeNode[data_List, children_List]?unconstructedQ:=
System`Private`SetNoEntry[Unevaluated@n]
newNode[data_, children_]:=
  System`Private`SetNoEntry@
    Unevaluated[TreeNode[data, children]]


(* ::Subsubsection::Closed:: *)
(*Destructor Operations*)



(* basic destructors *)
TreeQ//Clear
TreeQ[q_Tree]:=System`Private`NoEntryQ[q];
TreeQ[_]:=False;


TreeNodeQ//Clear
TreeNodeQ[q_TreeNode]:=System`Private`NoEntryQ[q];
TreeNodeQ[_]:=False


(* ::Subsubsection::Closed:: *)
(*treePosSpec*)



treePosSpec//Clear
treePosSpec[{}|None]:=
  {};
treePosSpec[pos:{__Integer}]:=
  Prepend[Riffle[pos, 2], 2];
treePosSpec[i_Integer]:=
  treePosSpec[{i}];


(* ::Subsubsection::Closed:: *)
(*treeHasDepth*)



treeHasDepth[t_, posSpec_]:=
  Quiet[Check[t[[Sequence@@posSpec]];True, False, Part::partw], Part::partw];


(* ::Subsubsection::Closed:: *)
(*Children*)



Tree::nochild="Tree doesn't have children at node `` and position ``";
TreeNode::nochild="TreeNode doesn't have children at node `` and position ``";


(* ::Subsubsubsection::Closed:: *)
(*treeChildren*)



treeChildren//Clear
treeChildren[
  head_,
  obj_,
  list_, 
  pos_
  ]:=
  With[{p=Flatten[{pos}, 1]},
    Module[
      {
        ps=Join[treePosSpec[Most@p], {2, Last@p}],
        $failed,
        c
        },
      c=
        Quiet[
          Check[
            list[[Sequence@@ps]],
            $failed,
            Part::partw], 
          Part::partw
          ];
      If[c=!=$failed,
        c,
        Message[head::nochild, Most@p, Last@p];
        Failure["NoChild", <|
          "MessageTemplate":>head::nochild,
          "MessageParameters":>{Most@p, Last@p, obj}
          |>
          ]
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeChildren*)



TreeChildren//Clear
TreeChildren[
  n:Tree[t_], 
  pos:{___Integer, _Integer|_Span|All}|_Integer|_Span|All:All
  ]:=
  With[{l=treeChildren[Tree, n, t, pos]},
    Which[
      Not@ListQ@l, 
        l,
      IntegerQ@pos||(ListQ[pos]&&IntegerQ@Last@pos),
        newNode@@l,
      True,
        newNode@@@l
      ]
    ];
TreeChildren[
  n:TreeNode[d_, t_], 
  pos:{___Integer, _Integer|_Span|All}|_Integer|_Span|All:All
  ]:=
  With[{l=treeChildren[TreeNode, n, t, pos]},
    Which[
      Not@ListQ@l, 
        l,
      IntegerQ@pos||(ListQ[pos]&&IntegerQ@Last@pos),
        newNode@@l,
      True,
        newNode@@@l
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*Data*)



Tree::nodata="Tree doesn't have data at node `` and position ``";
TreeNode::nodata="TreeNode doesn't have data at node `` and position ``";


(* ::Subsubsubsection::Closed:: *)
(*treeData*)



treeData//Clear
treeData[
  head_,
  obj_,
  list_, 
  pos_
  ]:=
  With[{p=Flatten[{pos}, 1]},
    Module[
      {
        ps=Join[treePosSpec[Most@p], {1, Last@p}],
        $failed,
        c
        },
      c=
        Quiet[
          Check[
            list[[Sequence@@ps]],
            $failed,
            Part::partw], 
          Part::partw
          ];
      If[c=!=$failed,
        c,
        Message[head::nodata, Most@p, Last@p];
        Failure["NoChild", <|
          "MessageTemplate":>head::nodata,
          "MessageParameters":>{Most@p, Last@p, obj}
          |>
          ]
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeData*)



TreeData//Clear
TreeData[
  n:Tree[t_], 
  pos:{___Integer, _Integer|_Span|All}|_Integer|_Span|All:1
  ]:=
  treeData[Tree, n, t, pos];
TreeData[
  n:TreeNode[d_, t_], 
  pos:{___Integer, _Integer|_Span|All}|_Integer|_Span|All:1
  ]:=
  treeData[TreeNode, n, {d, t}, pos];


(* ::Subsubsection::Closed:: *)
(*ChildCount*)



(* ::Subsubsubsection::Closed:: *)
(*TreeChildCount*)



TreeChildCount//Clear
TreeChildCount[
  n:Tree[t_], 
  pos:{___Integer}|_Integer:{}
  ]:=
  With[{l=treeChildren[Tree, n, t, Flatten[{pos, All}, 1]]},
    If[ListQ@l, Length@l, l]
    ];
TreeChildCount[
  n:TreeNode[d_, t_], 
  pos:{___Integer}|_Integer:{}
  ]:=
  With[{l=treeChildren[TreeNode, n, {d, t}, Flatten[{pos, All}, 1]]},
    If[ListQ@l, Length@l, l]
    ];


(* ::Subsubsection::Closed:: *)
(*Insert*)



Tree::noins="Tree can't insert at position `` in node ``";
TreeNode::noins="TreeNode can't insert at position `` in node ``";


(* ::Subsubsubsection::Closed:: *)
(*treeInsert*)



treeInsert//Clear
treeInsert[
  head_,
  obj_,
  list_, 
  node:{data_List, children_List}, 
  pos:{__Integer}|_Integer
  ]:=
  Module[
    {
      c, 
      $failed, 
      ps=treePosSpec[pos]
      },
    c=
      Quiet[
        Check[
          Insert[list, node, ps],
          $failed,
          Insert::ins
          ],
        Insert::ins
        ];
    If[c===$failed,
      With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
        Message[head::noins, p2, p1];
        Failure["NoInsert", <|
          "MessageTemplate":>head::noins,
          "MessageParameters":>{p2, p1, obj}
          |>
          ]
        ],
      c
      ]
    ];
treeInsert[
  head_,
  obj_,
  list_, 
  TreeNode[data_List, children_List], 
  pos:{__Integer}|_Integer
  ]:=
  treeInsert[head, obj, list, {data, children}, pos];


(* ::Subsubsubsection::Closed:: *)
(*TreeInsert*)



TreeInsert//Clear
TreeInsert[
  n:Tree[t_], 
  node:{data_List, children_List}|_TreeNode?TreeNodeQ, 
  pos:{__Integer}|_Integer:-1
  ]:=
  With[{l=treeInsert[Tree, n, t, node, pos]},
    If[ListQ@l, newTree[l], l]
    ];
TreeInsert[
  n:TreeNode[d_, t_], 
  node:{data_List, children_List}|_TreeNode?TreeNodeQ, 
  pos:{__Integer}|_Integer:-1
  ]:=
  With[{l=treeInsert[TreeNode, n, {d, t}, node, pos]},
    If[ListQ@l, newNode[d, l], l]
    ];
TreeInsert[
  n:_Tree|_TreeNode, 
  data_, 
  pos:{__Integer}|_Integer:-1
  ]:=
  TreeInsert[n, {{data}, {}}, pos]


(* ::Subsubsection::Closed:: *)
(*Replace*)



Tree::norep="Tree can't replace at position `` in node ``";
TreeNode::norep="TreeNode can't replace at position `` in node ``";


(* ::Subsubsubsection::Closed:: *)
(*treeReplace*)



treeReplace//Clear
treeReplace[
  head_,
  obj_,
  list_,  
  pos:{__Integer}|_Integer,
  node:{data_List, children_List}
  ]:=
  Module[
    {
      c, 
      $failed, 
      ps=treePosSpec[pos]
      },
    c=
      Quiet[
        Check[
          ReplacePart[list, ps->node],
          $failed,
          Insert::ins
          ],
        Insert::ins
        ];
    If[c===$failed,
      With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
        Message[head::norep, p2, p1];
        Failure["NoReplacement", <|
          "MessageTemplate":>head::norep,
          "MessageParameters":>{p2, p1, obj}
          |>
          ]
        ],
      c
      ]
    ];
treeReplace[
  head_,
  obj_,
  list_, 
  pos:{__Integer}|_Integer,
  TreeNode[data_List, children_List]
  ]:=
  treeReplace[head, obj, list, {data, children}, pos];


(* ::Subsubsubsection::Closed:: *)
(*TreeReplace*)



TreeReplace//Clear
TreeReplace[
  n:Tree[t_],  
  pos:{__Integer}|_Integer,
  node:{data_List, children_List}|_TreeNode?TreeNodeQ
  ]:=
  With[{l=treeReplace[Tree, n, t, pos, node]},
    If[ListQ@l, newTree[l], l]
    ];
TreeReplace[
  n:TreeNode[d_, t_], 
  pos:{__Integer}|_Integer,
  node:{data_List, children_List}|_TreeNode?TreeNodeQ
  ]:=
  With[{l=treeReplace[TreeNode, n, {d, t}, pos, node]},
    If[ListQ@l, newNode[d, l], l]
    ];
TreeReplace[
  n:_Tree|_TreeNode, 
  pos:{__Integer}|_Integer,
  data_
  ]:=
  TreeReplace[n, {{data}, {}}, pos]


(* ::Subsubsection::Closed:: *)
(*Pop*)



Tree::nopop="Tree can't pop node ``";
TreeNode::nopop="TreeNode can't pop node ``";


(* ::Subsubsubsection::Closed:: *)
(*treePop*)



treePop[
  head_,
  obj_,
  list_, 
  pos:{__Integer}|_Integer
  ]:=
  Module[
    {
      ps=treePosSpec[pos],
      $failed,
      c
      },
    c=
      Quiet[
        Check[list[[Sequence@@ps]], 
          $failed,
          Part::partw], 
        Part::partw
        ];
    If[c=!=$failed,
      {c, Delete[list, ps]},
      Message[head::nopop, pos];
      Failure["NoPop", <|
        "MessageTemplate":>head::nopop,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreePop*)



TreePop//Clear
TreePop[
  n:Tree[t_], 
  pos:{__Integer}|_Integer:-1
  ]:=
  With[{l=treePop[Tree, n, t, pos]},
    If[ListQ@l, {newNode@@l[[1]], newTree[l[[2]]]}, l]
    ];
TreePop[
  n:TreeNode[d_, t_], 
  pos:{__Integer}|_Integer:-1
  ]:=
  With[{l=treePop[TreeNode, n, {d, t}, pos]},
    If[ListQ@l, {newNode@@l[[1]], newNode@@l[[2]]}, l]
    ]


(* ::Subsubsection::Closed:: *)
(*InsertData*)



(* ::Subsubsubsection::Closed:: *)
(*treeInsertData*)



treeInsertData//Clear
treeInsertData[
  head_,
  obj_,
  list_, 
  data_,
  pos:{__Integer}|_Integer
  ]:=
  With[{p=Flatten[{pos}, 1]},
    Module[
      {
        c, 
        $failed, 
        ps=Join[treePosSpec[Most@p], {1, Last@p}]
        },
      c=
        Quiet[
          Check[
            Insert[list, data, ps],
            $failed,
            Insert::ins
            ],
          Insert::ins
          ];
      If[c===$failed,
        With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
          Message[head::noins, p2, p1];
          Failure["NoInsert", <|
            "MessageTemplate":>head::noins,
            "MessageParameters":>{p2, p1, obj}
            |>
            ]
          ],
        c
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeInsertData*)



TreeInsertData//Clear;
TreeInsertData[
  n:Tree[t_], 
  data_, 
  pos:{__Integer}|_Integer:1
  ]:=
  With[{l=treeInsertData[Tree, n, t, data, pos]},
    If[ListQ@l, newTree[l], l]
    ];
TreeInsertData[
  n:TreeNode[d_, t_], 
  data_,
  pos:{__Integer}|_Integer:1
  ]:=
  With[{l=treeInsertData[TreeNode, n, {d, t}, data, pos]},
    If[ListQ@l, newNode[d, l], l]
    ];


(* ::Subsubsection::Closed:: *)
(*ReplaceData*)



(* ::Subsubsubsection::Closed:: *)
(*treeReplaceData*)



treeReplaceData//Clear
treeReplaceData[
  head_,
  obj_,
  list_,  
  pos:{__Integer}|_Integer,
  data_
  ]:=
  With[{p=Flatten[{pos}, 1]},
    Module[
      {
        c, 
        $failed, 
        ps=Join[treePosSpec[Most@p], {1, Last@p}]
        },
      c=
        Quiet[
          Check[
            ReplacePart[list, ps->data],
            $failed,
            Insert::ins
            ],
          Insert::ins
          ];
      If[c===$failed,
        With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
          Message[head::norep, p2, p1];
          Failure["NoReplacement", <|
            "MessageTemplate":>head::norep,
            "MessageParameters":>{p2, p1, obj}
            |>
            ]
          ],
        c
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeReplaceData*)



TreeReplaceData//Clear;
TreeReplaceData[
  n:Tree[t_], 
  pos:{__Integer}|_Integer:1,
  data_
  ]:=
  With[{l=treeReplaceData[Tree, n, t, pos, data]},
    If[ListQ@l, newTree[l], l]
    ];
TreeReplaceData[
  n:TreeNode[d_, t_],
  pos:{__Integer}|_Integer:1,
  data_
  ]:=
  With[{l=treeReplaceData[TreeNode, n, {d, t}, pos, data]},
    If[ListQ@l, newNode[d, l], l]
    ];


(* ::Subsubsection::Closed:: *)
(*PopData*)



(* ::Subsubsubsection::Closed:: *)
(*treePopData*)



treePopData//Clear
treePopData[
  head_,
  obj_,
  list_, 
  pos:{__Integer}|_Integer
  ]:=
  Module[
    {
      ps=With[{p=Flatten[{pos}, 1]}, Join[treePosSpec[Most[p]], {1, Last[p]}]],
      $failed,
      c
      },
    c=
      Quiet[
        Check[list[[Sequence@@ps]], 
          $failed,
          Part::partw], 
        Part::partw
        ];
    If[c=!=$failed,
      {c, Delete[list, ps]},
      Message[head::nopop, pos];
      Failure["NoPop", <|
        "MessageTemplate":>head::nopop,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreePopData*)



TreePopData//Clear
TreePopData[
  n:Tree[t_], 
  pos:{__Integer}|_Integer:1
  ]:=
  With[{l=treePopData[Tree, n, t, pos]},
    If[ListQ@l, {l[[1]], newTree[l[[2]]]}, l]
    ];
TreePopData[
  n:TreeNode[d_, t_], 
  pos:{__Integer}|_Integer:-1
  ]:=
  With[{l=treePopData[TreeNode, n, {d, t}, pos]},
    If[ListQ@l, {l[[1]], newNode@@l[[2]]}, l]
    ]


(* ::Subsubsection::Closed:: *)
(*InsertSequence*)



(* ::Subsubsubsection::Closed:: *)
(*treeInsertSequence*)



treeInsertSequence//Clear
treeInsertSequence[
  head_,
  obj_,
  list_, 
  nodes:_List,
  pos:{__Integer}|_Integer
  ]:=
  Module[
    {
      c, 
      $failed, 
      ps=treePosSpec[pos]
      },
    c=
      Quiet[
        Check[
          Internal`InheritedBlock[{Insert},
            SetAttributes[Insert, SequenceHold];
            Insert[list, Sequence@@nodes, ps]
            ],
          $failed,
          Insert::ins
          ],
        Insert::ins
        ];
    If[c===$failed,
      With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
        Message[head::noins, p2, p1];
        Failure["NoInsert", <|
          "MessageTemplate":>head::noins,
          "MessageParameters":>{p2, p1, obj}
          |>
          ]
        ],
      c
      ]
    ];
treeInsert[
  head_,
  obj_,
  list_, 
  TreeNode[data_List, children_List], 
  pos:{__Integer}|_Integer
  ]:=
  treeInsert[head, obj, list, {data, children}, pos];


(* ::Subsubsubsection::Closed:: *)
(*TreeInsertSequence*)



TreeInsertSequence//Clear
TreeInsertSequence[
  n:Tree[t_], 
  nodes:{({_List, _List}|_TreeNode?TreeNodeQ)..}, 
  pos:{__Integer}|_Integer:-1
  ]:=
  With[{l=treeInsertSequence[Tree, n, t, nodes, pos]},
    If[ListQ@l, newTree[l], l]
    ];
TreeInsertSequence[
  n:TreeNode[d_, t_], 
  nodes:{({_List, _List}|_TreeNode?TreeNodeQ)..}, 
  pos:{__Integer}|_Integer:-1
  ]:=
  With[{l=treeInsertSequence[TreeNode, n, {d, t}, nodes, pos]},
    If[ListQ@l, newNode[d, l], l]
    ];
TreeInsertSequence[
  n:_Tree|_TreeNode, 
  data_List, 
  pos:{__Integer}|_Integer:-1
  ]:=
  TreeInsertSequence[n, 
    Replace[data, 
      e:Except[{_List, _List}|_TreeNode?TreeNodeQ]:>{{e}, {}},
      1
      ], 
    pos
    ]


(* ::Subsubsection::Closed:: *)
(*ReplaceSequence*)



(* ::Subsubsubsection::Closed:: *)
(*treeReplaceSequence*)



treeReplaceSequence//Clear
treeReplaceSequence[
  head_,
  obj_,
  list_,  
  pos:{__Integer}|_Integer,
  nodes_
  ]:=
  Module[
    {
      c, 
      $failed, 
      ps=treePosSpec[pos],
      n=Replace[nodes, TreeNode[d_, l_]:>{d, l}, 1]
      },
    c=
      Quiet[
        Check[
          ReplacePart[list, 
            With[{pl=ConstantArray[0, Length@ps-1]},
              MapIndexed[ps+Append[pl, #2[[1]]]->#&, n]
              ]
            ],
          $failed,
          Insert::ins
          ],
        Insert::ins
        ];
    If[c===$failed,
      With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
        Message[head::norep, p2, p1];
        Failure["NoReplacement", <|
          "MessageTemplate":>head::norep,
          "MessageParameters":>{p2, p1, obj}
          |>
          ]
        ],
      c
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeReplace*)



TreeReplaceSequence//Clear
TreeReplace[
  n:Tree[t_],  
  pos:{__Integer}|_Integer,
  nodes:{({_List, _List}|_TreeNode?TreeNodeQ)..}
  ]:=
  With[{l=treeReplaceSequence[Tree, n, t, pos, nodes]},
    If[ListQ@l, newTree[l], l]
    ];
TreeReplace[
  n:TreeNode[d_, t_], 
  pos:{__Integer}|_Integer,
  nodes:{({_List, _List}|_TreeNode?TreeNodeQ)..}
  ]:=
  With[{l=treeReplaceSequence[TreeNode, n, {d, t}, pos, nodes]},
    If[ListQ@l, newNode[d, l], l]
    ];
TreeReplaceSequence[
  n:_Tree|_TreeNode, 
  pos:{__Integer}|_Integer,
  data_
  ]:=
  TreeReplaceSequence[n, 
    Replace[data, 
      e:Except[{_List, _List}|_TreeNode?TreeNodeQ]:>{{e}, {}},
      1
      ], 
    pos
    ]


(* ::Subsubsection::Closed:: *)
(*PopSequence*)



(* ::Subsubsubsection::Closed:: *)
(*treePopSequence*)



treePopSequence[
  head_,
  obj_,
  list_, 
  pos:{p___Integer, which_}
  ]:=
  Module[
    {
      ps=With[{ps1=treePosSpec[{p}]}, Append[ps1, #]&/@which],
      $failed,
      c
      },
    c=
      Quiet[
        Check[Extract[list, ps], 
          $failed,
          Part::partw], 
        Part::partw
        ];
    If[c=!=$failed,
      {c, Delete[list, ps]},
      Message[head::nopop, pos];
      Failure["NoPop", <|
        "MessageTemplate":>head::nopop,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreePopSequence*)



TreePopSequence//Clear
TreePopSequence[
  n:Tree[t_], 
  pos:{___Integer, {__Integer}}|{__Integer}
  ]:=
  With[{l=treePopSequence[Tree, n, t, pos]},
    If[ListQ@l, {newNode@@@l[[1]], newTree[l[[2]]]}, l]
    ];
TreePopSequence[
  n:TreeNode[d_, t_], 
  pos:{___Integer, {__Integer}}|{__Integer}
  ]:=
  With[{l=treePopSequence[TreeNode, n, {d, t}, pos]},
    If[ListQ@l, {newNode@@@l[[1]], newNode@@l[[2]]}, l]
    ]


(* ::Subsubsection::Closed:: *)
(*TreeWalk*)



(* ::Text:: *)
(*

We\[CloseCurlyQuote]ll provide like three events?
	- \[OpenCurlyDoubleQuote]EnterNode\[CloseCurlyDoubleQuote]
	- \[OpenCurlyDoubleQuote]ProcessNode\[CloseCurlyDoubleQuote]
	- \[OpenCurlyDoubleQuote]ExitNode\[CloseCurlyDoubleQuote]
	
*)



(* ::Subsubsubsection::Closed:: *)
(*walkTreeDF*)



(* ::Text:: *)
(*
	Simple depth-first traversal of a node
*)



walkTreeDF[root_, handlers:{body_, enter_, exit_}]:=  
  Module[{node, children, res},
    node = enter[root];
    res=
      body[
        {
          node[[1]],
          walkTreeDF[#, handlers]&/@node[[2]]
          },
        node
        ];
    exit[res, node]
    ];


(* ::Subsubsubsection::Closed:: *)
(*walkTreeBF*)



walkTreeBF[root_, handlers:{body_, enter_, exit_}]:=  
    Module[
      {
        node = root,
        children, 
        res,
        q = Queue[]
        },
      Reap[
        q = QueuePush[q, node];
        Reap[
          While[!QueueEmptyQ[q],
            node = QueuePop[q];
            node = enter[node];
            children = root["Children"];
            q = QueueExtend[q, children];
            res = body[node, node];
            Sow[exit[res, node], "tmpResults"]
            ],
          "tmpResults"
          ][[2, 1]],
        "WalkTree"
        ][[2]]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeWalk*)



(* ::Subsubsubsubsection::Closed:: *)
(*$TreeTraversalFunctions*)



$TreeTraversalFunctions=
  <|
    "DepthFirst"-><|
      "EnterNode"->(#&),
      "ExitNode"->(#&),
      "ProcessNode"->(#&)
      |>,
    "BreadthFirst"-><|
      "EnterNode"->(#&),
      "ExitNode"->(Sow[#, "WalkTree"]&),
      "ProcessNode"->(#&)
      |>
    |>;


(* ::Subsubsubsubsection::Closed:: *)
(*iTreeWalk*)



Options[iTreeWalk]=
  {
    "TraversalFunction"->"DepthFirst"
    };
iTreeWalk[node_, visitFunctions_,
  ops:OptionsPattern[]
  ]:=
  Module[
    {
      mode, enter, exit, body,
      funcs
      },
    mode=
      Replace[
        OptionValue[iTreeWalk, 
          FilterRules[{ops}, "TraversalFunction"], 
          "TraversalFunction"
          ],
        {
          "BreadthFirst"->walkTreeBF,
          "DepthFirst"->walkTreeDF
          }
        ];
    funcs = 
      Lookup[$TreeTraversalFunctions, mode, $TreeTraversalFunctions["DepthFirst"]];
    enter=Lookup[visitFunctions, "EnterNode",   funcs["EnterNode"]];
    exit =Lookup[visitFunctions, "ExitNode",    funcs["ExitNode"]];
    body =Lookup[visitFunctions, "ProcessNode", funcs["ProcessNode"]];
    mode[node, {body, enter, exit}]
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*TreeWalk*)



Options[TreeWalk]=
  Options[iTreeWalk];
TreeWalk[Tree[t_], visitFunctions_, ops:OptionsPattern[]]:=
  iTreeWalk[t, visitFunctions, ops];
TreeWalk[TreeNode[d_, t_], visitFunctions_, ops:OptionsPattern[]]:=
  iTreeWalk[{d, t}, visitFunctions, ops];


(* ::Subsubsection::Closed:: *)
(*Formatting*)



(* ::Subsubsubsection::Closed:: *)
(*Tree*)



Format[q_Tree?TreeQ, StandardForm]:=
  RawBoxes@
    BoxForm`ArrangeSummaryBox[
      Tree,
      q,
      None,
      {
        BoxForm`MakeSummaryItem[
          {
            "Root:", 
              Quiet@Check[TreeData[q], None, Tree::nodata]
            }, 
          StandardForm
          ],
        BoxForm`MakeSummaryItem[
          {
            "Children:", 
              Quiet@Check[TreeChildCount[q], 0, Tree::nochild]
            }, 
          StandardForm
          ]
        },
      {},
      StandardForm
      ];
Format[q_Tree?Tree, TextForm]:=
  "Tree[<>]"


(* ::Subsubsubsection::Closed:: *)
(*Node*)



Format[q_TreeNode?TreeNodeQ, StandardForm]:=
  RawBoxes@
    BoxForm`ArrangeSummaryBox[
      TreeNode,
      q,
      None,
      {
        BoxForm`MakeSummaryItem[
          {
            "Root:", 
              Quiet@
                Check[TreeData[q], None, TreeNode::nodata]
            }, 
          StandardForm
          ],
        BoxForm`MakeSummaryItem[
          {
            "Children:", 
              Quiet@Check[TreeChildCount[q], 0, TreeNode::nochild]
            }, 
          StandardForm
          ]
        },
      {},
      StandardForm
      ];
Format[q_TreeNode?TreeNodeQ, TextForm]:=
  "TreeNode[<>]"


End[];



