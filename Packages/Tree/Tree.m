(* ::Package:: *)

(* Autogenerated Package *)

Tree::usage="A Tree data structure";
TreeQ::usage="Tests whether is actual Tree";


TreeNode::usage="A TreeNode object which exists as a symbolic wrapper on node data";
TreeNodeQ::usage="Tests whether is actual TreeNode";


TreeCore::usage="Extracts the core Tree backend";


TreeData::usage="Extracts data from a node";
TreeChildren::usage="Pulls children out of a node";
TreeChildCount::usage="Counts the number of leaves in the tree";


TreeInsert::usage="Inserts a node into a tree";
TreePop::usage="Pops a node (and children) from a tree";
TreeReplace::usage="Replaces a node in a tree";


TreeInsertData::usage="Inserts into the data field of each node";
TreePopData::usage="Deletes from the data field of each node";
TreeReplaceData::usage="Replaces data in a tree";


TreeInsertSequence::usage="Inserts a sequence of nodes into a Tree";
TreeReplaceSequence::usage="Replaces a sequence of nodes in a Tree";
TreePopSequence::usage="Pops a sequence of nodes in a Tree";


TreeWalk::usage="Walks a tree";


Begin["`Private`"];


(* ::Text:: *)
(*
	We\[CloseCurlyQuote]ll use a linked-list implementation to get efficient sub-tree-ing
	This will feel rather like our Stack implementation, honestly... but rather than introducing pushes and pops we\[CloseCurlyQuote]ll introduce tree insertion, deletion, rearrangement, and walking
	
	It might be the case that this would be better done via a basic linked-Association type format where each node gets a nested list index as its key. Insertions at the bottom of the tree would then be fast, but rearrangement of nodes would be very slow...
	
	Probably we need many types of trees for 
*)



(* ::Subsection:: *)
(*Tree*)



(* ::Subsubsection::Closed:: *)
(*Constructor*)



(* ::Text:: *)
(*
	I should probably move all my TreeNode stuff to holding just a single list... just haven\[CloseCurlyQuote]t gotten around it it yet. Does it make sense to even have a TreeNode structure? Or should everything just be a Tree because it really all is just a Tree?
*)



(* ::Subsubsubsection::Closed:: *)
(*prepTreeData*)



prepTreeData[{body_, kids_}]:=
  Catch[
    {
      Flatten[{body}, 1],
      Replace[Flatten[{kids}, 1],
        {
          Tree[t_]?TreeQ:>t,
          TreeNode[d_, c_]?TreeNodeQ:>{d, c},
          {a_, b_}:>{a, prepTreeData/@b}
          },
        1
        ]
      },
    "BadData",
    $Failed&
    ];
prepTreeData[e_]:=$Failed


(* ::Subsubsubsection::Closed:: *)
(*Tree*)



Tree//ClearAll;
Tree[]:=Tree[{{}, {}}];


validateTreeData[l_List]:=
  Length[l]==2&&
    AllTrue[validateTreeData, l[[2]]]


unconstructedQ=
  Function[Null, System`Private`EntryQ[Unevaluated[#]], HoldFirst];
q:Tree[l_List]?unconstructedQ:=
With[{d=prepTreeData[l]},
  System`Private`SetNoEntry[Unevaluated@Tree[d]]/;ListQ[d]
  ];


newTree[list_]:=
  System`Private`SetNoEntry@
    Unevaluated[Tree[list]]


Tree[t_Tree?TreeQ]:=t;
Tree[TreeNode[d__]?TreeNodeQ]:=newTree[{d}];


(* ::Subsubsubsection::Closed:: *)
(*TreeNode*)



TreeNode//Clear
TreeNode[]:=TreeNode[{}(* data field *), {}(*children field *)];
n:TreeNode[data_List, children_List]?unconstructedQ:=
  With[{d=prepTreeData[{data, children}]},
    Replace[d,
      {
        {dd_, cc_}:>
          System`Private`SetNoEntry[Unevaluated@TreeNode[dd, cc]]
        }
      ]/;ListQ[d]
   ];
newNode[data_, children_]:=
  System`Private`SetNoEntry@
    Unevaluated[TreeNode[data, children]];
newNode[{data_, children_}]:=
  newNode[data, children]


TreeNode[Tree[{d__}]?TreeQ]:=TreeNode[d];
TreeNode[t_TreeNode?TreeNodeQ]:=t;


(* ::Subsubsection::Closed:: *)
(*Destructor Operations*)



(* basic destructors *)
TreeQ//Clear
TreeQ[q_Tree]:=System`Private`NoEntryQ[q];
TreeQ[_]:=False;


TreeNodeQ//Clear
TreeNodeQ[q_TreeNode]:=System`Private`NoEntryQ[q];
TreeNodeQ[_]:=False


TreeCore[Tree[t_]]:=t;
TreeCore[TreeNode[a_, b_]]:={a, b};


(* ::Subsubsection::Closed:: *)
(*treePosSpec*)



treePosSpec//Clear
treePosSpec[{}|None]:=
  {};
treePosSpec[pos:{__Integer}]:=
  Prepend[Riffle[pos, 2], 2];
treePosSpec[i_Integer]:=
  treePosSpec[{i}];


(* ::Subsubsection::Closed:: *)
(*treeHasDepth*)



treeHasDepth[t_, posSpec_]:=
  Quiet[Check[t[[Sequence@@posSpec]];True, False, Part::partw], Part::partw];


(* ::Subsubsection::Closed:: *)
(*Children*)



Tree::nochild="Tree doesn't have children at node `` and position ``";
TreeNode::nochild="TreeNode doesn't have children at node `` and position ``";


(* ::Subsubsubsection::Closed:: *)
(*treeChildren*)



treeChildren//Clear
treeChildren[
  head_,
  obj_,
  list_, 
  pos_
  ]:=
  With[{p=Flatten[{pos}, 1]},
    Module[
      {
        ps=Join[treePosSpec[Most@p], {2, Last@p}],
        $failed,
        c
        },
      c=
        Quiet[
          Check[
            list[[Sequence@@ps]],
            $failed,
            Part::partw], 
          Part::partw
          ];
      If[c=!=$failed,
        c,
        Message[head::nochild, Most@p, Last@p];
        Failure["NoChild", <|
          "MessageTemplate":>head::nochild,
          "MessageParameters":>{Most@p, Last@p, obj}
          |>
          ]
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeChildren*)



TreeChildren//Clear


(* ::Text:: *)
(*
	Optimized puller for most common ops
*)



TreeChildren[n:Tree[{_, c_}], Optional[All, All]]:=
  newNode@@@c;
TreeChildren[n:TreeNode[_, c_], Optional[All, All]]:=
  newNode@@@c;


(* ::Text:: *)
(*
	Flexible fallback for the rest
*)



TreeChildren[
  n:Tree[t_], 
  pos:{___Integer, _Integer|_Span|All}|_Integer|_Span
  ]:=
  With[{l=treeChildren[Tree, n, t, pos]},
    Which[
      Not@ListQ@l, 
        l,
      IntegerQ@pos||(ListQ[pos]&&IntegerQ@Last@pos),
        newNode@@l,
      True,
        newNode@@@l
      ]
    ];
TreeChildren[
  n:TreeNode[d_, t_], 
  pos:{___Integer, _Integer|_Span|All}|_Integer|_Span|All:All
  ]:=
  With[{l=treeChildren[TreeNode, n, t, pos]},
    Which[
      Not@ListQ@l, 
        l,
      IntegerQ@pos||(ListQ[pos]&&IntegerQ@Last@pos),
        newNode@@l,
      True,
        newNode@@@l
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*Data*)



Tree::nodata="Tree doesn't have data at node `` and position ``";
TreeNode::nodata="TreeNode doesn't have data at node `` and position ``";


(* ::Subsubsubsection::Closed:: *)
(*treeData*)



treeData//Clear
treeData[
  head_,
  obj_,
  list_, 
  pos_
  ]:=
  With[{p=Flatten[{pos}, 1]},
    Module[
      {
        ps=Join[treePosSpec[Most@p], {1, Last@p}],
        $failed,
        c
        },
      c=
        Quiet[
          Check[
            list[[Sequence@@ps]],
            $failed,
            Part::partw], 
          Part::partw
          ];
      If[c=!=$failed,
        c,
        Message[head::nodata, Most@p, Last@p];
        Failure["NoChild", <|
          "MessageTemplate":>head::nodata,
          "MessageParameters":>{Most@p, Last@p, obj}
          |>
          ]
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeData*)



TreeData//Clear


(* ::Text:: *)
(*
	Optimized for most common case
*)



TreeData[Tree[{{d_, ___}, _}], Optional[1, 1]]:=
  d;
TreeData[TreeNode[{d_, ___}, t_], Optional[1, 1]]:=
  d;
TreeData[t:Tree[{{}, _}], Optional[1, 1]]:=
  (
    Message[Tree::nodata, {}, 1];
    Failure["NoChild", <|
      "MessageTemplate":>Tree::nodata,
      "MessageParameters":>{{}, 1, t}
      |>
      ]
    );
TreeData[t:TreeNode[{}, _], Optional[1, 1]]:=
  (
    Message[TreeNode::nodata, {}, 1];
    Failure["NoChild", <|
      "MessageTemplate":>TreeNode::nodata,
      "MessageParameters":>{{}, 1, t}
      |>
      ]
    );


(* ::Text:: *)
(*
	Flexible puller for all other positions
*)



TreeData[
  n:Tree[t_], 
  pos:{___Integer, _Integer|_Span|All}|_Integer|_Span|All
  ]:=
  treeData[Tree, n, t, pos];
TreeData[
  n:TreeNode[d_, t_], 
  pos:{___Integer, _Integer|_Span|All}|_Integer|_Span|All
  ]:=
  treeData[TreeNode, n, {d, t}, pos];


(* ::Subsubsection::Closed:: *)
(*ChildCount*)



(* ::Subsubsubsection::Closed:: *)
(*TreeChildCount*)



TreeChildCount//Clear
TreeChildCount[
  n:Tree[t_], 
  pos:{___Integer}|_Integer:{}
  ]:=
  With[{l=treeChildren[Tree, n, t, Flatten[{pos, All}, 1]]},
    If[ListQ@l, Length@l, l]
    ];
TreeChildCount[
  n:TreeNode[d_, t_], 
  pos:{___Integer}|_Integer:{}
  ]:=
  With[{l=treeChildren[TreeNode, n, {d, t}, Flatten[{pos, All}, 1]]},
    If[ListQ@l, Length@l, l]
    ];


(* ::Subsubsection::Closed:: *)
(*Insert*)



Tree::noins="Tree can't insert at position `` in node ``";
TreeNode::noins="TreeNode can't insert at position `` in node ``";


(* ::Subsubsubsection::Closed:: *)
(*treeInsert*)



treeInsert//Clear
treeInsert[
  head_,
  obj_,
  list_, 
  node:{data_List, children_List}, 
  pos:{__Integer}|_Integer
  ]:=
  Module[
    {
      c, 
      $failed, 
      ps=treePosSpec[pos]
      },
    c=
      Quiet[
        Check[
          Insert[list, node, ps],
          $failed,
          Insert::ins
          ],
        Insert::ins
        ];
    If[c===$failed,
      With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
        Message[head::noins, p2, p1];
        Failure["NoInsert", <|
          "MessageTemplate":>head::noins,
          "MessageParameters":>{p2, p1, obj}
          |>
          ]
        ],
      c
      ]
    ];
treeInsert[
  head_,
  obj_,
  list_, 
  TreeNode[data_List, children_List], 
  pos:{__Integer}|_Integer
  ]:=
  treeInsert[head, obj, list, {data, children}, pos];
treeInsert[
  head_,
  obj_,
  list_, 
  Tree[t_], 
  pos:{__Integer}|_Integer
  ]:=
  treeInsert[head, obj, list, t, pos];


(* ::Subsubsubsection::Closed:: *)
(*TreeInsert*)



TreeInsert//Clear


(* ::Subsubsubsubsection::Closed:: *)
(*Opt*)



(* ::Text:: *)
(*
	Optimized for most common insert
*)



prepNode[Tree[t_]]:=t;
prepNode[TreeNode[{a_, b_}]]:={a, b};


TreeInsert[
  n:Tree[t_], 
  node:{data_List, children_List}|_Tree?TreeQ|_TreeNode?TreeNodeQ, 
  Optional[-1, -1]
  ]:=
  newTree[Insert[t, prepNode@node, {2, -1}]]
TreeInsert[
  n:TreeNode[d_, t_], 
  node:{data_List, children_List}|_Tree?TreeQ|_TreeNode?TreeNodeQ, 
  Optional[-1, -1]
  ]:=
  newNode[d, Append[t, prepNode@n]]


(* ::Subsubsubsubsection::Closed:: *)
(*General*)



(* ::Text:: *)
(*
	More flexible but likely slower insert
*)



TreeInsert[
  n:Tree[t_], 
  node:{data_List, children_List}|_Tree?TreeQ|_TreeNode?TreeNodeQ, 
  pos:{__Integer}|_Integer
  ]:=
  With[{l=treeInsert[Tree, n, t, node, pos]},
    If[ListQ@l, newTree[l], l]
    ];
TreeInsert[
  n:TreeNode[d_, t_], 
  node:{data_List, children_List}|_Tree?TreeQ|_TreeNode?TreeNodeQ, 
  pos:{__Integer}|_Integer
  ]:=
  With[{l=treeInsert[TreeNode, n, {d, t}, node, pos]},
    If[ListQ@l, newNode[d, l], l]
    ];
TreeInsert[
  n:_Tree|_TreeNode, 
  data_, 
  pos:{__Integer}|_Integer:-1
  ]:=
  TreeInsert[n, {{data}, {}}, pos]


(* ::Subsubsection::Closed:: *)
(*Replace*)



Tree::norep="Tree can't replace at position `` in node ``";
TreeNode::norep="TreeNode can't replace at position `` in node ``";


(* ::Subsubsubsection::Closed:: *)
(*treeReplace*)



treeReplace//Clear
treeReplace[
  head_,
  obj_,
  list_,  
  pos:{__Integer}|_Integer,
  node:{data_List, children_List}
  ]:=
  Module[
    {
      c, 
      $failed, 
      ps=treePosSpec[pos]
      },
    c=
      Quiet[
        Check[
          ReplacePart[list, ps->node],
          $failed,
          Insert::ins
          ],
        Insert::ins
        ];
    If[c===$failed,
      With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
        Message[head::norep, p2, p1];
        Failure["NoReplacement", <|
          "MessageTemplate":>head::norep,
          "MessageParameters":>{p2, p1, obj}
          |>
          ]
        ],
      c
      ]
    ];
treeReplace[
  head_,
  obj_,
  list_, 
  pos:{__Integer}|_Integer,
  TreeNode[data_List, children_List]
  ]:=
  treeReplace[head, obj, list, {data, children}, pos];


(* ::Subsubsubsection::Closed:: *)
(*TreeReplace*)



TreeReplace//Clear
TreeReplace[
  n:Tree[t_],  
  pos:{__Integer}|_Integer,
  node:{data_List, children_List}|_TreeNode?TreeNodeQ
  ]:=
  With[{l=treeReplace[Tree, n, t, pos, node]},
    If[ListQ@l, newTree[l], l]
    ];
TreeReplace[
  n:TreeNode[d_, t_], 
  pos:{__Integer}|_Integer,
  node:{data_List, children_List}|_TreeNode?TreeNodeQ
  ]:=
  With[{l=treeReplace[TreeNode, n, {d, t}, pos, node]},
    If[ListQ@l, newNode[d, l], l]
    ];
TreeReplace[
  n:_Tree|_TreeNode, 
  pos:{__Integer}|_Integer,
  data_
  ]:=
  TreeReplace[n, {{data}, {}}, pos]


(* ::Subsubsection::Closed:: *)
(*Pop*)



Tree::nopop="Tree can't pop node ``";
TreeNode::nopop="TreeNode can't pop node ``";


(* ::Subsubsubsection::Closed:: *)
(*treePop*)



treePop[
  head_,
  obj_,
  list_, 
  pos:{__Integer}|_Integer
  ]:=
  Module[
    {
      ps=treePosSpec[pos],
      $failed,
      c
      },
    c=
      Quiet[
        Check[list[[Sequence@@ps]], 
          $failed,
          Part::partw], 
        Part::partw
        ];
    If[c=!=$failed,
      {c, Delete[list, ps]},
      Message[head::nopop, pos];
      Failure["NoPop", <|
        "MessageTemplate":>head::nopop,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreePop*)



TreePop//Clear


(* ::Subsubsubsubsection::Closed:: *)
(*Opt*)



TreePop[
  Tree[{d_, c:{_, ___}}], 
  Optional[-1, -1]
  ]:=
  {newNode@@Last[c], newTree[{d, Most@c}]}
TreePop[
  TreeNode[d_, c:{_, ___}], 
  Optional[-1, -1]
  ]:=
  {newNode@@Last[c], newNode[d, Most@c]}


(* ::Subsubsubsubsection::Closed:: *)
(*General*)



TreePop[
  n:Tree[t_], 
  pos:{__Integer}|_Integer:-1
  ]:=
  With[{l=treePop[Tree, n, t, pos]},
    If[ListQ@l, {newNode@@l[[1]], newTree[l[[2]]]}, l]
    ];
TreePop[
  n:TreeNode[d_, t_], 
  pos:{__Integer}|_Integer:-1
  ]:=
  With[{l=treePop[TreeNode, n, {d, t}, pos]},
    If[ListQ@l, {newNode@@l[[1]], newNode@@l[[2]]}, l]
    ]


(* ::Subsubsection::Closed:: *)
(*InsertData*)



(* ::Subsubsubsection::Closed:: *)
(*treeInsertData*)



treeInsertData//Clear
treeInsertData[
  head_,
  obj_,
  list_, 
  data_,
  pos:{__Integer}|_Integer
  ]:=
  With[{p=Flatten[{pos}, 1]},
    Module[
      {
        c, 
        $failed, 
        ps=Join[treePosSpec[Most@p], {1, Last@p}]
        },
      c=
        Quiet[
          Check[
            Insert[list, data, ps],
            $failed,
            Insert::ins
            ],
          Insert::ins
          ];
      If[c===$failed,
        With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
          Message[head::noins, p2, p1];
          Failure["NoInsert", <|
            "MessageTemplate":>head::noins,
            "MessageParameters":>{p2, p1, obj}
            |>
            ]
          ],
        c
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeInsertData*)



TreeInsertData//Clear;
TreeInsertData[
  n:Tree[t_], 
  data_, 
  pos:{__Integer}|_Integer:1
  ]:=
  With[{l=treeInsertData[Tree, n, t, data, pos]},
    If[ListQ@l, newTree[l], l]
    ];
TreeInsertData[
  n:TreeNode[d_, t_], 
  data_,
  pos:{__Integer}|_Integer:1
  ]:=
  With[{l=treeInsertData[TreeNode, n, {d, t}, data, pos]},
    If[ListQ@l, newNode[d, l], l]
    ];


(* ::Subsubsection::Closed:: *)
(*ReplaceData*)



(* ::Subsubsubsection::Closed:: *)
(*treeReplaceData*)



treeReplaceData//Clear
treeReplaceData[
  head_,
  obj_,
  list_,  
  pos:{__Integer}|_Integer,
  data_
  ]:=
  With[{p=Flatten[{pos}, 1]},
    Module[
      {
        c, 
        $failed, 
        ps=Join[treePosSpec[Most@p], {1, Last@p}]
        },
      c=
        Quiet[
          Check[
            ReplacePart[list, ps->data],
            $failed,
            Insert::ins
            ],
          Insert::ins
          ];
      If[c===$failed,
        With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
          Message[head::norep, p2, p1];
          Failure["NoReplacement", <|
            "MessageTemplate":>head::norep,
            "MessageParameters":>{p2, p1, obj}
            |>
            ]
          ],
        c
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeReplaceData*)



TreeReplaceData//Clear;
TreeReplaceData[
  n:Tree[t_], 
  pos:{__Integer}|_Integer:1,
  data_
  ]:=
  With[{l=treeReplaceData[Tree, n, t, pos, data]},
    If[ListQ@l, newTree[l], l]
    ];
TreeReplaceData[
  n:TreeNode[d_, t_],
  pos:{__Integer}|_Integer:1,
  data_
  ]:=
  With[{l=treeReplaceData[TreeNode, n, {d, t}, pos, data]},
    If[ListQ@l, newNode[d, l], l]
    ];


(* ::Subsubsection::Closed:: *)
(*PopData*)



(* ::Subsubsubsection::Closed:: *)
(*treePopData*)



treePopData//Clear
treePopData[
  head_,
  obj_,
  list_, 
  pos:{__Integer}|_Integer
  ]:=
  Module[
    {
      ps=With[{p=Flatten[{pos}, 1]}, Join[treePosSpec[Most[p]], {1, Last[p]}]],
      $failed,
      c
      },
    c=
      Quiet[
        Check[list[[Sequence@@ps]], 
          $failed,
          Part::partw], 
        Part::partw
        ];
    If[c=!=$failed,
      {c, Delete[list, ps]},
      Message[head::nopop, pos];
      Failure["NoPop", <|
        "MessageTemplate":>head::nopop,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreePopData*)



TreePopData//Clear
TreePopData[
  n:Tree[t_], 
  pos:{__Integer}|_Integer:1
  ]:=
  With[{l=treePopData[Tree, n, t, pos]},
    If[ListQ@l, {l[[1]], newTree[l[[2]]]}, l]
    ];
TreePopData[
  n:TreeNode[d_, t_], 
  pos:{__Integer}|_Integer:-1
  ]:=
  With[{l=treePopData[TreeNode, n, {d, t}, pos]},
    If[ListQ@l, {l[[1]], newNode@@l[[2]]}, l]
    ]


(* ::Subsubsection::Closed:: *)
(*InsertSequence*)



(* ::Subsubsubsection::Closed:: *)
(*treeInsertSequence*)



treeInsertSequence//Clear
treeInsertSequence[
  head_,
  obj_,
  list_, 
  nodes:_List,
  pos:{__Integer}|_Integer
  ]:=
  Module[
    {
      c, 
      $failed, 
      ps=treePosSpec[pos]
      },
    c=
      Quiet[
        Check[
          Internal`InheritedBlock[{Insert},
            SetAttributes[Insert, SequenceHold];
            Insert[list, Sequence@@nodes, ps]
            ],
          $failed,
          Insert::ins
          ],
        Insert::ins
        ];
    If[c===$failed,
      With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
        Message[head::noins, p2, p1];
        Failure["NoInsert", <|
          "MessageTemplate":>head::noins,
          "MessageParameters":>{p2, p1, obj}
          |>
          ]
        ],
      c
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeInsertSequence*)



(* ::Subsubsubsubsection::Closed:: *)
(*Opt*)



TreeInsertSequence//Clear
TreeInsertSequence[
  n:Tree[{d_, c_}], 
  nodes:{{_List, _List}..}, 
  Optional[-1, -1]
  ]:=
  newTree[{d, Join[c, nodes]}];
TreeInsertSequence[
  n:TreeNode[d_, t_], 
  nodes:{{_List, _List}..}, 
  Optional[-1, -1]
  ]:=
  newTree[{d, Join[t, nodes]}]


(* ::Subsubsubsubsection::Closed:: *)
(*General*)



TreeInsertSequence//Clear
TreeInsertSequence[
  n:Tree[t_], 
  nodes:{{_List, _List}..}, 
  pos:{__Integer}|_Integer
  ]:=
  With[{l=treeInsertSequence[Tree, n, t, nodes, pos]},
    If[ListQ@l, newTree[l], l]
    ];
TreeInsertSequence[
  n:TreeNode[d_, t_], 
  nodes:{{_List, _List}..}, 
  pos:{__Integer}|_Integer
  ]:=
  With[{l=treeInsertSequence[TreeNode, n, {d, t}, nodes, pos]},
    If[ListQ@l, newNode[d, l], l]
    ];
TreeInsertSequence[
  n:_Tree|_TreeNode, 
  data_List, 
  pos:{__Integer}|_Integer
  ]:=
  TreeInsertSequence[n, 
    Replace[data, 
      {
        Tree[t_]?TreeQ:>t,
        TreeNode[d_, t_]?TreeNodeQ:>{d, t},
        e:Except[{_List, _List}]:>{{e}, {}}
        },
      1
      ], 
    pos
    ]


(* ::Subsubsection::Closed:: *)
(*ReplaceSequence*)



(* ::Subsubsubsection::Closed:: *)
(*treeReplaceSequence*)



treeReplaceSequence//Clear
treeReplaceSequence[
  head_,
  obj_,
  list_,  
  pos:{__Integer}|_Integer,
  nodes_
  ]:=
  Module[
    {
      c, 
      $failed, 
      ps=treePosSpec[pos],
      n=Replace[nodes, TreeNode[d_, l_]:>{d, l}, 1]
      },
    c=
      Quiet[
        Check[
          ReplacePart[list, 
            With[{pl=ConstantArray[0, Length@ps-1]},
              MapIndexed[ps+Append[pl, #2[[1]]]->#&, n]
              ]
            ],
          $failed,
          Insert::ins
          ],
        Insert::ins
        ];
    If[c===$failed,
      With[{p1=Most@Flatten@{pos}, p2=Last@Flatten@{pos}},
        Message[head::norep, p2, p1];
        Failure["NoReplacement", <|
          "MessageTemplate":>head::norep,
          "MessageParameters":>{p2, p1, obj}
          |>
          ]
        ],
      c
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeReplace*)



TreeReplaceSequence//Clear
TreeReplace[
  n:Tree[t_],  
  pos:{__Integer}|_Integer,
  nodes:{({_List, _List}|_TreeNode?TreeNodeQ)..}
  ]:=
  With[{l=treeReplaceSequence[Tree, n, t, pos, nodes]},
    If[ListQ@l, newTree[l], l]
    ];
TreeReplace[
  n:TreeNode[d_, t_], 
  pos:{__Integer}|_Integer,
  nodes:{({_List, _List}|_TreeNode?TreeNodeQ)..}
  ]:=
  With[{l=treeReplaceSequence[TreeNode, n, {d, t}, pos, nodes]},
    If[ListQ@l, newNode[d, l], l]
    ];
TreeReplaceSequence[
  n:_Tree|_TreeNode, 
  pos:{__Integer}|_Integer,
  data_
  ]:=
  TreeReplaceSequence[n, 
    Replace[data, 
      e:Except[{_List, _List}|_TreeNode?TreeNodeQ]:>{{e}, {}},
      1
      ], 
    pos
    ]


(* ::Subsubsection::Closed:: *)
(*PopSequence*)



(* ::Subsubsubsection::Closed:: *)
(*treePopSequence*)



treePopSequence[
  head_,
  obj_,
  list_, 
  pos:{p___Integer, which_}
  ]:=
  Module[
    {
      ps=With[{ps1=treePosSpec[{p}]}, Append[ps1, #]&/@which],
      $failed,
      c
      },
    c=
      Quiet[
        Check[Extract[list, ps], 
          $failed,
          Part::partw], 
        Part::partw
        ];
    If[c=!=$failed,
      {c, Delete[list, ps]},
      Message[head::nopop, pos];
      Failure["NoPop", <|
        "MessageTemplate":>head::nopop,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreePopSequence*)



TreePopSequence//Clear
TreePopSequence[
  n:Tree[t_], 
  pos:{___Integer, {__Integer}}|{__Integer}
  ]:=
  With[{l=treePopSequence[Tree, n, t, pos]},
    If[ListQ@l, {newNode@@@l[[1]], newTree[l[[2]]]}, l]
    ];
TreePopSequence[
  n:TreeNode[d_, t_], 
  pos:{___Integer, {__Integer}}|{__Integer}
  ]:=
  With[{l=treePopSequence[TreeNode, n, {d, t}, pos]},
    If[ListQ@l, {newNode@@@l[[1]], newNode@@l[[2]]}, l]
    ]


(* ::Subsubsection::Closed:: *)
(*TreeWalk*)



(* ::Text:: *)
(*

We\[CloseCurlyQuote]ll provide like three events?
	- \[OpenCurlyDoubleQuote]EnterNode\[CloseCurlyDoubleQuote]
	- \[OpenCurlyDoubleQuote]ProcessNode\[CloseCurlyDoubleQuote]
	- \[OpenCurlyDoubleQuote]ExitNode\[CloseCurlyDoubleQuote]

These\[CloseCurlyQuote]ll take the node data and a node children as a list
EnterNode will return a modified node
ProcessNode will take the result from EnterNode
ExitNode will take the result from ProcessNode and the original node?
	
*)



(* ::Subsubsubsection::Closed:: *)
(*walkTreeDF*)



(* ::Text:: *)
(*
	Simple depth-first traversal of a node
*)



walkTreeDF[root_, handlers:{body_, enter_, exit_}]:=  
  Module[{node, children, res},
    node = enter[root];
    res=
      body[
        {
          node[[1]],
          walkTreeDF[#, handlers]&/@node[[2]]
          }
        ];
    exit[res, node]
    ];


(* ::Subsubsubsection::Closed:: *)
(*walkTreeBF*)



walkTreeBF[root_, handlers:{body_, enter_, exit_}]:=  
    Module[
      {
        node = root, mod,
        children, 
        res,
        q = Queue[]
        },
      Reap[
        q = QueuePush[q, node];
        Reap[
          While[!QueueEmptyQ[q],
            {node, q} = QueuePop[q];
            mod = enter@node;
            children = mod[[2]];
            If[!ListQ@children,
              PackageRaiseException[
                Automatic,
                "\"EnterNode\" must return a List of Length 2 with \
a List as its second argument"
                ]
              ];
            q = QueueExtend[q, children];
            res = body[mod];
            Sow[exit[res, node], "tmpResults"]
            ],
          "tmpResults"
          ][[2, 1]],
        "WalkTree"
        ][[2]]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeWalk*)



(* ::Subsubsubsubsection::Closed:: *)
(*$TreeTraversalFunctions*)



$TreeTraversalFunctions=
  <|
    "DepthFirst"-><|
      "EnterNode"->(#&),
      "ExitNode"->(#&),
      "ProcessNode"->(#&)
      |>,
    "BreadthFirst"-><|
      "EnterNode"->(#&),
      "ExitNode"->(Sow[#, "WalkTree"]&),
      "ProcessNode"->(#&)
      |>
    |>;


(* ::Subsubsubsubsection::Closed:: *)
(*iTreeWalk*)



Options[iTreeWalk]=
  {
    "TraversalFunction"->"DepthFirst"
    };
iTreeWalk[node_, visitFunctions_,
  ops:OptionsPattern[]
  ]:=
  Module[
    {
      mode, enter, exit, body,
      funcs, res, tno, filt
      },
    filt = FilterRules[{ops}, Options[iTreeWalk]];
    mode=
      Replace[
        OptionValue[iTreeWalk, 
          filt, 
          "TraversalFunction"
          ],
        {
          "BreadthFirst"->walkTreeBF,
          "DepthFirst"->walkTreeDF
          }
        ];
    funcs = 
      Lookup[$TreeTraversalFunctions, mode, $TreeTraversalFunctions["DepthFirst"]];
    enter=Lookup[visitFunctions, "EnterNode",   funcs["EnterNode"]];
    exit =Lookup[visitFunctions, "ExitNode",    funcs["ExitNode"]];
    body =Lookup[visitFunctions, "ProcessNode", funcs["ProcessNode"]];
    res = mode[node, {body, enter, exit}];
    If[ListQ@res,
      res = Tree[res];
      If[TreeQ[res], res, res[[1]]],
      res
      ]
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*TreeWalk*)



Options[TreeWalk]=
  Options[iTreeWalk];
TreeWalk[Tree[t_], visitFunctions_, ops:OptionsPattern[]]:=
  iTreeWalk[t, visitFunctions, ops];
TreeWalk[TreeNode[d_, t_], visitFunctions_, ops:OptionsPattern[]]:=
  iTreeWalk[{d, t}, visitFunctions, ops];


(* ::Subsubsection::Closed:: *)
(*Formatting*)



(* ::Subsubsubsection::Closed:: *)
(*Tree*)



Format[q_Tree?TreeQ, StandardForm]:=
  RawBoxes@
    BoxForm`ArrangeSummaryBox[
      Tree,
      q,
      None,
      {
        BoxForm`MakeSummaryItem[
          {
            "Root:", 
              Quiet@Check[TreeData[q], None, Tree::nodata]
            }, 
          StandardForm
          ],
        BoxForm`MakeSummaryItem[
          {
            "Children:", 
              Quiet@Check[TreeChildCount[q], 0, Tree::nochild]
            }, 
          StandardForm
          ]
        },
      {},
      StandardForm
      ];
Format[q_Tree?Tree, TextForm]:=
  "Tree[<>]"


(* ::Subsubsubsection::Closed:: *)
(*Node*)



Format[q_TreeNode?TreeNodeQ, StandardForm]:=
  RawBoxes@
    BoxForm`ArrangeSummaryBox[
      TreeNode,
      q,
      None,
      {
        BoxForm`MakeSummaryItem[
          {
            "Root:", 
              Quiet@
                Check[TreeData[q], None, TreeNode::nodata]
            }, 
          StandardForm
          ],
        BoxForm`MakeSummaryItem[
          {
            "Children:", 
              Quiet@Check[TreeChildCount[q], 0, TreeNode::nochild]
            }, 
          StandardForm
          ]
        },
      {},
      StandardForm
      ];
Format[q_TreeNode?TreeNodeQ, TextForm]:=
  "TreeNode[<>]"


End[];



