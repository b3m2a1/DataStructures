(* ::Package:: *)

(* Autogenerated Package *)

Tree::usage="A Tree data structure";


TreeNode::usage="A TreeNode object which exists as a symbolic wrapper on node data";


TreeData::usage="Extracts data from a node";
TreeChildren::usage="Pulls children out of a node";
TreeChildCount::usage="Counts the number of leaves in the tree";


TreeInsert::usage="Inserts a node into a tree";
TreePop::usage="Pops a node (and children) from a tree";


TreeInsertData::usage="Inserts into the data field of each node";
TreePopData::usage="Deletes from the data field of each node";


Begin["`Private`"];


(* ::Text:: *)
(*
	We\[CloseCurlyQuote]ll use a linked-list implementation to get efficient sub-tree-ing
	This will feel rather like our Stack implementation, honestly... but rather than introducing pushes and pops we\[CloseCurlyQuote]ll introduce tree insertion, deletion, rearrangement, and walking
*)



(* ::Subsection:: *)
(*Tree*)



(* ::Subsubsection::Closed:: *)
(*Constructor*)



Tree//ClearAll;
Tree[]:=Tree[{}];
unconstructedQ=
  Function[Null, System`Private`EntryQ[Unevaluated[#]], HoldFirst];
q:Tree[l_List]?unconstructedQ:=
System`Private`SetNoEntry[Unevaluated@q]


newTree[list_]:=
  System`Private`SetNoEntry@
    Unevaluated[Tree[list]]


TreeNode[]:=TreeNode[{}(* data field *), {}(*children field *)];
n:TreeNode[data_List, children_List]?unconstructedQ:=
System`Private`SetNoEntry[Unevaluated@n]
newNode[data_, children_]:=
  System`Private`SetNoEntry@
    Unevaluated[TreeNode[data, children]]


(* ::Subsubsection::Closed:: *)
(*Destructor Operations*)



(* basic destructors *)
TreeQ[q_Tree]:=System`Private`NoEntryQ[q];


(* ::Subsubsection::Closed:: *)
(*treePosSpec*)



treePosSpec[pos:{__Integer}]:=
  Prepend[Riffle[pos, 2], 2];
treePosSpec[i_Integer]:=
  treePosSpec[{i}];


(* ::Subsubsection::Closed:: *)
(*treeHasDepth*)



treeHasDepth[t_, posSpec_]:=
  Quiet[Check[t[[Sequence@@posSpec]];True, False, Part::partw], Part::partw];


(* ::Subsubsection::Closed:: *)
(*Children*)



(* ::Subsubsubsection::Closed:: *)
(*treeChildren*)



treeChildren[
  head_,
  obj_,
  list_, 
  pos:{__Integer}|_Integer,
  children_
  ]:=
  Module[
    {
      ps=Join[treePosSpec[pos], {2, children}],
      $failed,
      c
      },
    c=
      Quiet[
        Check[list[[Sequence@@ps]], 
          $failed,
          Part::partw], 
        Part::partw
        ];
    If[c=!=$failed,
      c,
      Message[head::partw, pos, obj];
      Failure["BadPart", <|
        "MessageTemplate":>head::partw,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreeChildren*)



TreeChildren[
  n:Tree[t_], 
  pos:{__Integer}|_Integer,
  children:{___Integer}|_Integer|_Span|All:All
  ]:=
  With[{l=treeChildren[Tree, n, t, pos, children]},
    Which[
      Not@ListQ@l, 
        l,
      IntegerQ@children,
        newNode@@l,
      True,
        newNode@@@l
      ]
    ];
TreeChildren[
  n:TreeNode[d_, t_], 
  pos:{__Integer}|_Integer,
  children:{___Integer}|_Integer|_Span|All:All
  ]:=
  With[{l=treeChildren[TreeNode, n, t, pos, children]},
    Which[
      Not@ListQ@l, 
        l,
      IntegerQ@children,
        newNode@@l,
      True,
        newNode@@@l
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*Insert*)



(* ::Subsubsubsection::Closed:: *)
(*treeInsert*)



treeInsert[
  head_,
  obj_,
  list_, 
  node:{data_List, children_List}, 
  pos:{__Integer}|_Integer
  ]:=
  Module[{c, $failed, ps=treePosSpec[pos]},
    c=
      Quiet[
        Check[
          Insert[list, node, ps],
          $failed,
          Insert::ins
          ],
        Insert::ins
        ];
    If[c===$failed,
      Message[head::partw, pos, obj];
      Failure["BadPart", <|
        "MessageTemplate":>head::partw,
        "MessageParameters":>{pos, obj}
        |>
        ],
      c
      ]
    ];
treeInsert[
  head_,
  obj_,
  list_, 
  TreeNode[data_List, children_List], 
  pos:{__Integer}|_Integer
  ]:=
  treeInsert[head, obj, list, {data, children}, pos];


(* ::Subsubsubsection::Closed:: *)
(*TreeInsert*)



TreeInsert[
  n:Tree[t_], 
  node:{data_List, children_List}|_TreeNode?TreeNodeQ, 
  pos:{__Integer}|_Integer
  ]:=
  With[{l=treeInsert[Tree, n, t, node, pos]},
    If[ListQ@l, newTree[l], l]
    ];
TreeInsert[
  n:TreeNode[d_, t_], 
  node:{data_List, children_List}|_TreeNode?TreeNodeQ, 
  pos:{__Integer}|_Integer
  ]:=
  With[{l=treeInsert[TreeNode, n, t, node, pos]},
    If[ListQ@l, newNode[data, l], l]
    ];
TreeInsert[
  n:_Tree|_TreeNode, 
  data_, 
  pos:{__Integer}|_Integer
  ]:=
  TreeInsert[n, {data, {}}, pos]


(* ::Subsubsection::Closed:: *)
(*Pop*)



(* ::Subsubsubsection::Closed:: *)
(*treePop*)



treePop[
  head_,
  obj_,
  list_, 
  pos:{__Integer}|_Integer
  ]:=
  Module[
    {
      ps=treePosSpec[pos],
      $failed,
      c
      },
    c=
      Quiet[
        Check[list[[Sequence@@ps]], 
          $failed,
          Part::partw], 
        Part::partw
        ];
    If[c=!=$failed,
      {c, Delete[list, ps]},
      Message[head::partw, pos, obj];
      Failure["BadPart", <|
        "MessageTemplate":>head::partw,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*TreePop*)



TreePop[
  n:Tree[t_], 
  pos:{__Integer}|_Integer
  ]:=
  With[{l=treePop[Tree, n, t, pos]},
    If[ListQ@l, {newNode@@l[[1]], newTree[l[[2]]]}, l]
    ];
TreePop[
  n:TreeNode[d_, t_], 
  pos:{__Integer}|_Integer
  ]:=
  With[{l=treePop[TreeNode, n, t, pos]},
    If[ListQ@l, {newNode@@l[[1]], newTree[l[[2]]]}, l]
    ]


(* ::Subsubsection::Closed:: *)
(*Formatting*)



Format[q_Tree?TreeQ, StandardForm]:=
RawBoxes@
BoxForm`ArrangeSummaryBox[
Tree,
q,
None,
{
BoxForm`MakeSummaryItem[{"", ""}, StandardForm]
},
{},
StandardForm
];
Format[q_Tree?Tree, TextForm]:=
"Tree[<>]"


End[];



