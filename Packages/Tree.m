(* ::Package:: *)

(* Autogenerated Package *)

Tree::usage="A Tree data structure";


TreeNode::usage="A TreeNode object which exists as a symbolic wrapper on node data";


TreeData::usage="Extracts data from a node";
TreeChildren::usage="Pulls children out of a node";
TreeChildCount::usage="Counts the number of leaves in the tree";


TreeInsert::usage="Inserts a node into a tree";
TreePop::usage="Pops a node (and children) from a tree";


TreeInsertData::usage="Inserts into the data field of each node";
TreePopData::usage="Deletes from the data field of each node";


Begin["`Private`"];


(* ::Text:: *)
(*
	We\[CloseCurlyQuote]ll use a linked-list implementation to get efficient sub-tree-ing
	This will feel rather like our Stack implementation, honestly... but rather than introducing pushes and pops we\[CloseCurlyQuote]ll introduce tree insertion, deletion, rearrangement, and walking
*)



(* ::Subsection:: *)
(*Tree*)



(* ::Subsubsection::Closed:: *)
(*Constructor*)



Tree//ClearAll;
Tree[]:=Tree[{}];
unconstructedQ=
  Function[Null, System`Private`EntryQ[Unevaluated[#]], HoldFirst];
q:Tree[l_List]?unconstructedQ:=
System`Private`SetNoEntry[Unevaluated@q]


newTree[list_]:=
  System`Private`SetNoEntry@
    Unevaluated[Tree[list]]


TreeNode[]:=TreeNode[{}(* data field *), {}(*children field *)];
n:TreeNode[data_List, children_List]?unconstructedQ:=
System`Private`SetNoEntry[Unevaluated@n]
newNode[data_, children_]:=
  System`Private`SetNoEntry@
    Unevaluated[TreeNode[data, children]]


(* ::Subsubsection::Closed:: *)
(*Destructor Operations*)



(* basic destructors *)
TreeQ[q_Tree]:=System`Private`NoEntryQ[q];


(* ::Subsubsection::Closed:: *)
(*treePosSpec*)



treePosSpec[pos:{__Integer}]:=
  Prepend[Riffle[pos, 2], 2];
treePosSpec[i_Integer]:=
  treePosSpec[{i}];


(* ::Subsubsection::Closed:: *)
(*treeHasDepth*)



treeHasDepth[t_, posSpec_]:=
  Quiet[Check[t[[Sequence@@posSpec]];True, False, Part::partw], Part::partw];


(* ::Subsubsection::Closed:: *)
(*Children*)



treeChildren[
  head_,
  obj_,
  list_, 
  node:{data_List, children_List}, 
  pos:{__Integer}|Integer
  ]:=
  With[{ps=treePosSpec[pos]},
    If[treeHasDepth[list, ps],
      Insert[list, node, ps],
      Message[head::partw, pos, obj];
      Failure["BadPart", <|
        "MessageTemplate":>head::partw,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];
treeInsert[
  head_,
  obj_,
  list_, 
  TreeNode[data_List, children_List], 
  pos:{__Integer}|Integer
  ]:=
  treeInsert[head, obj, list, {data, children}, pos];


(* ::Subsubsection::Closed:: *)
(*Insert*)



treeInsert[
  head_,
  obj_,
  list_, 
  node:{data_List, children_List}, 
  pos:{__Integer}|Integer
  ]:=
  With[{ps=treePosSpec[pos]},
    If[treeHasDepth[list, ps],
      Insert[list, node, ps],
      Message[head::partw, pos, obj];
      Failure["BadPart", <|
        "MessageTemplate":>head::partw,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];
treeInsert[
  head_,
  obj_,
  list_, 
  TreeNode[data_List, children_List], 
  pos:{__Integer}|Integer
  ]:=
  treeInsert[head, obj, list, {data, children}, pos];


TreeInsert[
  n:Tree[t_], 
  node:{data_List, children_List}|_TreeNode?TreeNodeQ, 
  pos:{__Integer}|Integer
  ]:=
  With[{l=treeInsert[Tree, n, t, node, pos]},
    If[ListQ@l, newTree[l], l]
    ];
TreeInsert[
  n:TreeNode[d_, t_], 
  node:{data_List, children_List}|_TreeNode?TreeNodeQ, 
  pos:{__Integer}|Integer
  ]:=
  With[{l=treeInsert[TreeNode, n, t, node, pos]},
    If[ListQ@l, newNode[data, l], l]
    ];


(* ::Subsubsection::Closed:: *)
(*Pop*)



(* ::Subsubsection::Closed:: *)
(*Insert*)



treePop[
  head_,
  obj_,
  list_, 
  node:{data_List, children_List}, 
  pos:{__Integer}|Integer
  ]:=
  With[{ps=treePosSpec[pos]},
    If[treeHasDepth[list, ps],
      Insert[list, node, ps],
      Message[head::partw, pos, obj];
      Failure["BadPart", <|
        "MessageTemplate":>head::partw,
        "MessageParameters":>{pos, obj}
        |>
        ]
      ]
    ];
treeInsert[
  head_,
  obj_,
  list_, 
  TreeNode[data_List, children_List], 
  pos:{__Integer}|Integer
  ]:=
  treeInsert[head, obj, list, {data, children}, pos];


TreeInsert[
  n:Tree[t_], 
  node:{data_List, children_List}|_TreeNode?TreeNodeQ, 
  pos:{__Integer}|Integer
  ]:=
  With[{l=treeInsert[Tree, n, t, node, pos]},
    If[ListQ@l, newTree[l], l]
    ];
TreeInsert[
  n:TreeNode[d_, t_], 
  node:{data_List, children_List}|_TreeNode?TreeNodeQ, 
  pos:{__Integer}|Integer
  ]:=
  With[{l=treeInsert[TreeNode, n, t, node, pos]},
    If[ListQ@l, newNode[data, l], l]
    ];


(* ::Subsubsection::Closed:: *)
(*Formatting*)



Format[q_StackQueue?StackQ, StandardForm]:=
RawBoxes@
BoxForm`ArrangeSummaryBox[
StackQueue,
q,
None,
{
BoxForm`MakeSummaryItem[{"Size:", StackSize[q]}, StandardForm]
},
{},
StandardForm
];
Format[q_StackQueue?StackQ, TextForm]:=
"StackQueue[<>]"


End[];



